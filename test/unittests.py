# -*- coding: utf-8 -*-
import unittest
try:
    str = unicode
except NameError:
    pass  # Forward compatibility with py3k (unicode is not defined)

from textwrap import dedent as d
import protobuf_extra
from test.Person_pb2 import Person, Date


class DictionaryToString(unittest.TestCase):

    def check(self, dictionary_representation, expected):
        actual = protobuf_extra.DictionaryToString(dictionary_representation)
        self.assertEqual(actual, expected)

    def test_numeric_types(self):
        """
        Numeric data types (except complex).
        """
        self.check({"int": 8}, u'int: 8\n')
        self.check({"float": 3.2}, u'float: 3.2\n')
        self.check({"long": 1}, u'long: 1\n')

    def test_string_types(self):
        """
        For protobuf string type, you can use both Python str (unicode).
        """
        self.check({"str": "foo"}, u'str: "foo"\n')
        self.check({"unicode": u"bar"}, u'unicode: "bar"\n')

    def test_bytes_types(self):
        """
        For protobuf bytes, Python bytes works (escape the non-ASCII
        bytes).
        """
        self.check({"bytes": b"A\x95B"}, u'bytes: "A\\225B"\n')

    def test_boolean_types(self):
        self.check({"bool": True}, u'bool: true\n')

    def test_repeated_field(self):
        """
        Repeated fields can be represented with a list or a tuple.
        """
        self.check({"list": [1, 2, 3]}, u'list: 1\nlist: 2\nlist: 3\n')
        self.check({"tuple": (True, False)}, u'tuple: true\ntuple: false\n')

    def test_nested_message(self):
        """
        Nested messages are represented as nested dictionaries.
        """
        self.check({"dict": {"foo": "bar"}}, d(u'''\
        dict {
            foo: "bar"
        }
        '''))

    def test_enum(self):
        """
        Protobuf enumerations are just numbers in Python, but in code you
        can use the symbolic constants generated by the proto compiler.

        See also the enum support in MessageToString(m).
        """
        self.check({"enum": Person.MALE}, u'enum: 2\n')

    def test_converter(self):
        from datetime import date

        @protobuf_extra.converter(date)
        def date_to_dict(date_instance):
            """
            A function that takes a datetime.date instance, and returns
            a test.Person_pb2.Date compatible Python dictionary.
            """
            return {"year": date_instance.year,
                    "month": date_instance.month,
                    "day": date_instance.day}
        self.check({'birthday': date(2013, 10, 5)}, d(u"""\
        birthday {
            day: 5
            month: 10
            year: 2013
        }
        """))
        # just to clear the state
        del protobuf_extra.fromPythonConverters[0]


class MessageToString(unittest.TestCase):

    def check(self, m, expected):
        actual = protobuf_extra.MessageToString(m)
        self.assertEqual(actual, expected)

    def test_empty(self):
        person = Person()
        self.check(person, '')

    def test_basic(self):
        person = Person()
        person.name = "John Doe"
        person.birthday.year = 1970
        person.birthday.month = 1
        person.birthday.day = 1
        self.check(person, d('''\
        name: "John Doe"
        birthday {
          year: 1970
          month: 1
          day: 1
        }
        '''))

    def test_enum(self):
        """
        Unlike DictionaryToString(d), MessageToString(m) is capable
        of showing the symbolic constants generated by the proto compiler.

        This is because here we have the Message subclass to introspect.
        """
        person = Person()
        person.gender = Person.MALE
        self.check(person, 'gender: MALE\n')

    def test_template(self):
        """
        Ability to create a template ASCII representation of a Message subclass.

        Contrast this with the output of MessageToDictionary(Person).
        Scalar types have the emptyish default value, but repeated scalars
        don't appear at all since there is no ASCII representation for an
        empty list.
        """
        self.check(Person, d('''\
        age: 0
        birthday {
            day: 0
            month: 0
            year: 0
        }
        children {
            age: 0
            birthday {
                day: 0
                month: 0
                year: 0
            }
            d: 0.0
            data: ""
            f: 0.0
            f32: 0
            f64: 0
            flag: false
            gender: 0
            i32: 0
            i64: 0
            is_married: true
            name: ""
            nationality: 0
            s32: 0
            s64: 0
            sf32: 0
            sf64: 0
            text: ""
            u32: 0
            u64: 0
        }
        d: 0.0
        data: ""
        f: 0.0
        f32: 0
        f64: 0
        flag: false
        gender: 0
        i32: 0
        i64: 0
        is_married: true
        name: ""
        nationality: 0
        s32: 0
        s64: 0
        sf32: 0
        sf64: 0
        text: ""
        u32: 0
        u64: 0
        '''))


class MessageToDictionary(unittest.TestCase):

    def check(self, m, expected):
        actual = protobuf_extra.MessageToDictionary(m)
        self.assertEqual(actual, expected)

    def test_empty(self):
        """
        For the dictionary representation, it does not matter whether the
        message is complete or not (required fields can be missing).
        """
        self.check(Person(), {})

    def test_unicode(self):
        person = Person()
        person.name = u'John Doe'
        self.check(person, {'name': u'John Doe'})

    def test_int(self):
        person = Person()
        person.age = 18
        self.check(person, {'age': 18})

    def test_enum(self):
        """
        Enumerators in Python are just integers when printed.

        But you can use the symbolic constants, including enum aliases, in
        code.
        """
        person = Person()
        person.gender = Person.MALE
        self.check(person, {'gender': 2})
        person = Person()
        person.nationality = Person.FOREIGN
        dictionary_representation = protobuf_extra.MessageToDictionary(person)
        self.assertTrue(dictionary_representation['nationality'] == Person.ALIEN)

    def test_repeated_field(self):
        person = Person()
        person.emails.append(u'john@doe.com')
        person.emails.append(u'john@doe.net')
        self.check(person, {'emails': [u'john@doe.com', u'john@doe.net']})

    def test_nested_messages(self):
        person = Person()
        child = person.children.add()
        child.name = u'Tiivi'
        child = person.children.add()
        child.name = u'Taavi'
        self.check(person, {'children': [
            {'name': u'Tiivi'},
            {'name': u'Taavi'}
        ]})

    def test_string_types(self):
        """
        Protobuf string types are always Python str (unicode),
        even when the it could be str.
        """
        person = Person()
        person.text = u"äää"
        dictionary_representation = protobuf_extra.MessageToDictionary(person)
        self.assertTrue(isinstance(dictionary_representation['text'], str))
        person = Person()
        person.text = "aaa"
        dictionary_representation = protobuf_extra.MessageToDictionary(person)
        self.assertTrue(isinstance(dictionary_representation['text'], str))

    def test_bytes_types(self):
        """
        Protobuf bytes type is Python bytes.
        """
        person = Person()
        person.data = b"aaa"
        dictionary_representation = protobuf_extra.MessageToDictionary(person)
        self.assertTrue(isinstance(dictionary_representation['data'], bytes))

    def test_boolean_types(self):
        person = Person()
        person.flag = True
        self.check(person, {'flag': True})

    def test_numeric_types(self):
        person = Person()
        person.d = 3.2123
        person.f = 3.2123
        person.i32 = 32
        person.i64 = 64
        person.u32 = 32
        person.u64 = 64
        person.s32 = -32
        person.s64 = -64
        person.f32 = 32
        person.f64 = 64
        person.sf32 = -32
        person.sf64 = -64
        self.check(person, {
            'd': 3.2123,
            'f': 3.2123,
            'i32': 32,
            'i64': 64,
            'u32': 32,
            'u64': 64,
            's32': -32,
            's64': -64,
            'f32': 32,
            'f64': 64,
            'sf32': -32,
            'sf64': -64
        })

    def test_custom_types(self):
        from datetime import date

        @protobuf_extra.converter(Date)
        def dict_to_date(dict_instance):
            """
            A function that takes a test.Person_pb2.Date compatible
            Python dictionary instance, and returns a datetime.date instance.
            """
            return date(dict_instance["year"],
                        dict_instance["month"],
                        dict_instance["day"])

        person = Person()
        person.birthday.year = 1970
        person.birthday.month = 1
        person.birthday.day = 1
        self.check(person, {'birthday': date(1970, 1, 1)})
        # Just clear the state
        del protobuf_extra.toPythonConverters[0]

    def test_template(self):
        """
        The message class can be used to build a template.

        Some notes about the above dictionary:

          * all scalar types have an emptyish default value

          * nested messages have a nested dictionary (e.g. 'birthday')

          * repeated scalar types have an empty list, but repeated nested
            message types have one element list

          * recursive nested messages do not recurse more than one level
            deep (e.g. 'children')

        This functionality is only meant for generating a template from a
        Protobuf Message type.
        """
        self.check(Person, {
            'age': 0,
            'birthday': {
                'month': 0,
                'day': 0,
                'year': 0},
            'children': [
                {
                    'text': u'',
                    'u64': 0,
                    'i64': 0,
                    'sf32': 0,
                    'children': [],
                    'u32': 0,
                    'is_married': True,
                    'f64': 0,
                    'keys': [],
                    's32': 0,
                    'sf64': 0,
                    'flag': False,
                    'birthday': {
                        'month': 0,
                        'day': 0,
                        'year': 0
                    },
                    'nationality': 0,
                    'data': '',
                    'emails': [],
                    'd': 0,
                    'name': u'',
                    'f': 0,
                    'i32': 0,
                    'age': 0,
                    'f32': 0,
                    'gender': 0,
                    's64': 0
                }
            ],
            'd': 0,
            'data': '',
            'emails': [],
            'f': 0,
            'f32': 0,
            'f64': 0,
            'flag': False,
            'gender': 0,
            'i32': 0,
            'i64': 0,
            'is_married': True,
            'keys': [],
            'name': u'',
            'nationality': 0,
            's32': 0,
            's64': 0,
            'sf32': 0,
            'sf64': 0,
            'text': u'',
            'u32': 0,
            'u64': 0
        })

    def test_template_custom_types(self):
        """
        Templates also supports custom Python types.  Note that converters need
        to deal with any impedance mismatch between different types.
        """
        from datetime import date

        @protobuf_extra.converter(Date)
        def dict_to_date(dict_instance):
            """
            A function that takes a test.Person_pb2.Date compatible
            Python dictionary instance, and returns a datetime.date instance.

            Here, default (0,0,0) protobuf Date is translated to (1,1,1) Python date.
            """
            try:
                return date(dict_instance["year"],
                            dict_instance["month"],
                            dict_instance["day"])
            except ValueError:
                # Our protobuf Date is more relaxed that Python datetime.date.
                # In this example, the date constructor fails because default
                # Date is all zeros, and that is not alright with Python date.
                # Instead of doing any recovery (like a real app would), let's
                # just waste space with this overly long comment and return
                # a dummy date.
                return date(1, 1, 1)

        person_dict = protobuf_extra.MessageToDictionary(Person)
        self.assertEqual(person_dict["birthday"], date(1, 1, 1))

        # Just clear the state
        del protobuf_extra.toPythonConverters[0]


class MessageToBinary(unittest.TestCase):

    def test_required_fields(self):
        from google.protobuf.message import EncodeError

        person = Person()
        self.assertRaisesRegexp(EncodeError,
                                'Message test.Person is missing required fields: name,birthday',
                                protobuf_extra.MessageToBinary, person)

    def test_partial(self):
        person = Person()
        binaryJohnDoe = protobuf_extra.MessageToBinary(person, partial=True)

    def test_ok(self):
        person = Person()
        person.name = "John Doe"
        person.birthday.year = 1970
        person.birthday.month = 1
        person.birthday.day = 1
        binaryJohnDoe = protobuf_extra.MessageToBinary(person)

    def test_class(self):
        from google.protobuf.message import EncodeError

        self.assertRaisesRegexp(EncodeError,
                                'Message test.Person is missing required fields: name,birthday',
                                protobuf_extra.MessageToBinary, Person)

        binaryRepresentation = protobuf_extra.MessageToBinary(Person, partial=True)
